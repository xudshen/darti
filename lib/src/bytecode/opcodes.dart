/// Opcode definitions for the dartic bytecode ISA.
///
/// All opcodes occupy 8 bits (0x00-0xFF). Unused slots are filled with
/// ILLEGAL entries that trigger an error in the dispatch loop.
///
/// See: docs/design/01-bytecode-isa.md
enum Opcode {
  // ── Load/Store (0x00-0x0F) ──
  nop(0x00),
  loadConst(0x01),
  loadNull(0x02),
  loadTrue(0x03),
  loadFalse(0x04),
  loadInt(0x05),
  loadConstInt(0x06),
  loadConstDbl(0x07),
  moveRef(0x08),
  moveVal(0x09),
  loadUpvalue(0x0A),
  storeUpvalue(0x0B),
  boxInt(0x0C),
  boxDouble(0x0D),
  unboxInt(0x0E),
  unboxDouble(0x0F),

  // ── Integer Arithmetic (0x10-0x1F) ──
  addInt(0x10),
  subInt(0x11),
  mulInt(0x12),
  divInt(0x13),
  modInt(0x14),
  negInt(0x15),
  bitAnd(0x16),
  bitOr(0x17),
  bitXor(0x18),
  bitNot(0x19),
  shl(0x1A),
  shr(0x1B),
  ushr(0x1C),
  addIntImm(0x1D),
  illegal1E(0x1E),
  illegal1F(0x1F),

  // ── Float Arithmetic (0x20-0x2F) ──
  addDbl(0x20),
  subDbl(0x21),
  mulDbl(0x22),
  divDbl(0x23),
  negDbl(0x24),
  intToDbl(0x25),
  dblToInt(0x26),
  illegal27(0x27),
  illegal28(0x28),
  illegal29(0x29),
  illegal2A(0x2A),
  illegal2B(0x2B),
  illegal2C(0x2C),
  illegal2D(0x2D),
  illegal2E(0x2E),
  illegal2F(0x2F),

  // ── Comparison (0x30-0x3F) ──
  ltInt(0x30),
  leInt(0x31),
  gtInt(0x32),
  geInt(0x33),
  eqInt(0x34),
  ltDbl(0x35),
  leDbl(0x36),
  gtDbl(0x37),
  geDbl(0x38),
  eqDbl(0x39),
  eqRef(0x3A),
  eqGeneric(0x3B),
  illegal3C(0x3C),
  illegal3D(0x3D),
  illegal3E(0x3E),
  illegal3F(0x3F),

  // ── Control Flow (0x40-0x4F) ──
  jump(0x40),
  jumpIfTrue(0x41),
  jumpIfFalse(0x42),
  jumpIfNull(0x43),
  jumpIfNnull(0x44),
  jumpAx(0x45),
  illegal46(0x46),
  illegal47(0x47),
  illegal48(0x48),
  illegal49(0x49),
  illegal4A(0x4A),
  illegal4B(0x4B),
  illegal4C(0x4C),
  illegal4D(0x4D),
  illegal4E(0x4E),
  illegal4F(0x4F),

  // ── Call & Return (0x50-0x5F) ──
  call(0x50),
  callStatic(0x51),
  callHost(0x52),
  callVirtual(0x53),
  callSuper(0x54),
  returnRef(0x55),
  returnVal(0x56),
  returnNull(0x57),
  illegal58(0x58),
  illegal59(0x59),
  illegal5A(0x5A),
  illegal5B(0x5B),
  illegal5C(0x5C),
  illegal5D(0x5D),
  illegal5E(0x5E),
  illegal5F(0x5F),

  // ── Object Operations (0x60-0x6F) ──
  getFieldRef(0x60),
  setFieldRef(0x61),
  getFieldVal(0x62),
  setFieldVal(0x63),
  newInstance(0x64),
  instanceOf(0x65),
  cast(0x66),
  getFieldDyn(0x67),
  setFieldDyn(0x68),
  illegal69(0x69),
  illegal6A(0x6A),
  illegal6B(0x6B),
  illegal6C(0x6C),
  illegal6D(0x6D),
  illegal6E(0x6E),
  illegal6F(0x6F),

  // ── Closure (0x70-0x77) ──
  closure(0x70),
  closeUpvalue(0x71),
  illegal72(0x72),
  illegal73(0x73),
  illegal74(0x74),
  illegal75(0x75),
  illegal76(0x76),
  illegal77(0x77),

  // ── Generics & Types (0x78-0x7F) ──
  pushIta(0x78),
  pushFta(0x79),
  loadTypeArg(0x7A),
  instantiateType(0x7B),
  createTypeArgs(0x7C),
  allocGeneric(0x7D),
  checkCovariant(0x7E),
  illegal7F(0x7F),

  // ── Async & Generators (0x80-0x8F) ──
  initAsync(0x80),
  await_(0x81),
  asyncReturn(0x82),
  asyncThrow(0x83),
  initAsyncStar(0x84),
  yield_(0x85),
  yieldStar(0x86),
  initSyncStar(0x87),
  awaitStreamNext(0x88),
  illegal89(0x89),
  illegal8A(0x8A),
  illegal8B(0x8B),
  illegal8C(0x8C),
  illegal8D(0x8D),
  illegal8E(0x8E),
  illegal8F(0x8F),

  // ── Collection (0x90-0x97) ──
  createList(0x90),
  createMap(0x91),
  createSet(0x92),
  createRecord(0x93),
  illegal94(0x94),
  illegal95(0x95),
  illegal96(0x96),
  illegal97(0x97),

  // ── String & Dynamic (0x98-0x9F) ──
  stringInterp(0x98),
  addGeneric(0x99),
  invokeDyn(0x9A),
  illegal9B(0x9B),
  illegal9C(0x9C),
  illegal9D(0x9D),
  illegal9E(0x9E),
  illegal9F(0x9F),

  // ── Global Variables (0xA0-0xA3) ──
  loadGlobal(0xA0),
  storeGlobal(0xA1),
  illegalA2(0xA2),
  illegalA3(0xA3),

  // ── Exception & Assert (0xA4-0xA7) ──
  throw_(0xA4),
  rethrow_(0xA5),
  assert_(0xA6),
  nullCheck(0xA7),

  // ── Reserved / Superinstruction (0xA8-0xFD) ──
  illegalA8(0xA8),
  illegalA9(0xA9),
  illegalAA(0xAA),
  illegalAB(0xAB),
  illegalAC(0xAC),
  illegalAD(0xAD),
  illegalAE(0xAE),
  illegalAF(0xAF),
  illegalB0(0xB0),
  illegalB1(0xB1),
  illegalB2(0xB2),
  illegalB3(0xB3),
  illegalB4(0xB4),
  illegalB5(0xB5),
  illegalB6(0xB6),
  illegalB7(0xB7),
  illegalB8(0xB8),
  illegalB9(0xB9),
  illegalBA(0xBA),
  illegalBB(0xBB),
  illegalBC(0xBC),
  illegalBD(0xBD),
  illegalBE(0xBE),
  illegalBF(0xBF),
  illegalC0(0xC0),
  illegalC1(0xC1),
  illegalC2(0xC2),
  illegalC3(0xC3),
  illegalC4(0xC4),
  illegalC5(0xC5),
  illegalC6(0xC6),
  illegalC7(0xC7),
  illegalC8(0xC8),
  illegalC9(0xC9),
  illegalCA(0xCA),
  illegalCB(0xCB),
  illegalCC(0xCC),
  illegalCD(0xCD),
  illegalCE(0xCE),
  illegalCF(0xCF),
  illegalD0(0xD0),
  illegalD1(0xD1),
  illegalD2(0xD2),
  illegalD3(0xD3),
  illegalD4(0xD4),
  illegalD5(0xD5),
  illegalD6(0xD6),
  illegalD7(0xD7),
  illegalD8(0xD8),
  illegalD9(0xD9),
  illegalDA(0xDA),
  illegalDB(0xDB),
  illegalDC(0xDC),
  illegalDD(0xDD),
  illegalDE(0xDE),
  illegalDF(0xDF),
  illegalE0(0xE0),
  illegalE1(0xE1),
  illegalE2(0xE2),
  illegalE3(0xE3),
  illegalE4(0xE4),
  illegalE5(0xE5),
  illegalE6(0xE6),
  illegalE7(0xE7),
  illegalE8(0xE8),
  illegalE9(0xE9),
  illegalEA(0xEA),
  illegalEB(0xEB),
  illegalEC(0xEC),
  illegalED(0xED),
  illegalEE(0xEE),
  illegalEF(0xEF),
  illegalF0(0xF0),
  illegalF1(0xF1),
  illegalF2(0xF2),
  illegalF3(0xF3),
  illegalF4(0xF4),
  illegalF5(0xF5),
  illegalF6(0xF6),
  illegalF7(0xF7),
  illegalF8(0xF8),
  illegalF9(0xF9),
  illegalFA(0xFA),
  illegalFB(0xFB),
  illegalFC(0xFC),
  illegalFD(0xFD),

  // ── System (0xFE-0xFF) ──
  wide(0xFE),
  halt(0xFF);

  const Opcode(this.code);

  /// The numeric opcode value (0x00-0xFF).
  final int code;

  /// Lookup table for O(1) index-to-opcode conversion.
  static final List<Opcode> _byIndex = _buildLookup();

  static List<Opcode> _buildLookup() {
    final table = List<Opcode>.filled(256, Opcode.nop);
    for (final op in values) {
      table[op.code] = op;
    }
    return table;
  }

  /// Returns the [Opcode] for the given numeric [code].
  static Opcode byCode(int code) => _byIndex[code];
}
