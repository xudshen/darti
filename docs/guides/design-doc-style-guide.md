# 设计文档风格指南

本指南规定 `docs/design/` 下所有章节的写作标准。目标：设计文档应描述**为什么这样设计**和**如何工作**，而非充当带注释的参考实现。

## 章节模板

每章改写后须包含以下结构（可按需增减子节，但必需节不可省略）：

```
# Chapter N: [主题]

## 模块定位            ← 必需。2-4 句话：是什么、解决什么、在架构中的层次
## 与其他模块的关系      ← 必需。输入依赖 / 输出被依赖 / 契约接口
## 设计决策            ← 必需。三列表格：选择 / 备选方案与拒绝理由 / 理由
## 核心概念            ← 必需。ASCII 图或属性列表描述数据结构
## 工作流程            ← 必需。ASCII 数据流图 + 编号步骤，可用伪代码
## 关键约束与边界条件    ← 必需。数值限制集中列出（含来源依据）
## 已知局限与演进路径    ← 必需。Phase 2 待办 + 触发条件
## 附录：参考实现（可选）← 核心算法用 <details> 折叠保留
```

### 必需节清单

| 节名 | 最低要求 |
|------|---------|
| 模块定位 | 2-4 句话说明模块职责和架构位置 |
| 与其他模块的关系 | 至少列出输入来源和输出去向，引用具体章节号 |
| 设计决策 | 每个决策至少包含"选择"、"备选方案与拒绝理由"、"理由"三列 |
| 核心概念 | 用非代码方式（表格、属性列表、ASCII 图）描述数据结构 |
| 工作流程 | 带编号的步骤描述，或 ASCII 流程图 |
| 关键约束与边界条件 | 列出数值限制及来源 |
| 已知局限与演进路径 | 至少标注 Phase 2 计划和触发条件 |

---

## 代码使用规则

### 允许保留的代码形式

| 类型 | 示例 | 理由 |
|------|------|------|
| 操作码表 | `0x10 ADD_INT A, B, C ...` | 这是规范定义，不是实现代码 |
| 编码格式 ASCII 图 | `[op:8][A:8][B:8][C:8]` | 结构描述，不是可执行代码 |
| 数据结构字段表格 | 字段名/类型/用途 三列表格 | 比代码更清晰 |
| 文件格式图 | `.darticb` 二进制布局 | 规范定义 |
| 伪代码片段 | 算法步骤中的 2-5 行关键逻辑 | 辅助理解流程 |

### 必须删除或移入附录的代码

| 类型 | 处理方式 |
|------|---------|
| 完整类定义（class ... { }） | 改为属性列表或字段表格 |
| 完整方法实现 | 改为编号步骤描述 |
| 样板代码（构造函数、getter/setter） | 直接删除 |
| 核心算法的完整实现 | 移入附录，用 `<details>` 折叠 |
| 重复出现的代码（跨章节） | 保留一处，其他改为"详见 ChN"引用 |

### 代码密度目标

- **目标**：每章代码行占比 < 15%
- **计算方式**：代码行 = ` ```dart` / ` ```` 围栏内的行数 + 内联代码块中超过一行的代码
- **豁免**：操作码表、编码格式图、文件格式图不计入代码行

---

## 图表规范

### ASCII 图

- 用于架构图、数据流图、栈布局、文件格式
- 宽度不超过 80 列（等宽字体下不换行）
- 使用 Unicode box drawing 字符：`┌ ┐ └ ┘ ├ ┤ ┬ ┴ ┼ │ ─ ►`
- 每张图须有标题或上下文说明

### 表格

- 用于属性列表、决策记录、检查项、约束值
- 优先使用 Markdown 表格，列数 ≤ 5
- 表头必须有明确的列名

---

## 设计决策表格式

三列格式（扩展自原有两列）：

```markdown
| 决策项 | 选择 | 备选方案与拒绝理由 | 理由 |
|--------|------|-------------------|------|
| 指令宽度 | 固定 32 位 | 16 位变长：解码复杂，分支预测差 | 缓存行容纳 16 条指令 |
```

- "备选方案与拒绝理由"列展示设计思考过程
- 如果当时没有认真考虑备选方案，写"未评估"
- 拒绝理由要具体（"性能差"不够，"解码需 2 次内存访问"够）

---

## Phase 2 标注格式

统一使用以下格式标注未来工作：

```markdown
> **Phase 2**：[简述内容]。触发条件：[何时需要实施]。
```

示例：
> **Phase 2**：多态 IC（2-4 条目）。触发条件：profiling 显示单态命中率 < 85%。

---

## ARCHITECTURE.md 与 Ch0 的职责划分

| 内容 | 归属 | 处理原则 |
|------|------|---------|
| 架构分层 ASCII 图 | ARCHITECTURE.md | Ch0 引用"详见 ARCHITECTURE.md" |
| 术语表 | ARCHITECTURE.md | Ch0 不重复 |
| 项目定位（1-2 句） | ARCHITECTURE.md | Ch0 不重复 |
| 目标场景详述 | Ch0 | ARCHITECTURE.md 简述后引用 Ch0 |
| 性能目标与数据 | Ch0 | ARCHITECTURE.md 只写结论 |
| 编译执行流程图 | Ch0 | ARCHITECTURE.md 用简化版 |
| 竞品对比表 | Ch0 | 仅 Ch0 持有 |
| 语言特性支持范围 | Ch0 | 仅 Ch0 持有 |
| 设计文档索引 | ARCHITECTURE.md | 带输入/输出列 |
| 跨章节依赖拓扑 | Ch0 | 仅 Ch0 持有 |
| 文档导读 | Ch0 | 仅 Ch0 持有 |
| 关键设计不变式 | Ch0 | 仅 Ch0 持有 |

**原则**：ARCHITECTURE.md 是"指路牌"（快速了解项目 + 找到详细文档），Ch0 是"权威总览"（完整的架构描述）。两者之间通过引用链接，不重复内容。

---

## 合格 / 不合格示例

### 不合格：数据结构用完整类定义

```dart
class ValueStack {
  final Uint8List _buffer;
  late final Int64List intView;
  late final Float64List doubleView;
  int sp = 0;

  ValueStack(int maxSlots)
      : _buffer = Uint8List(maxSlots * 8) {
    intView = Int64List.view(_buffer.buffer);
    doubleView = Float64List.view(_buffer.buffer);
  }
}
```

### 合格：数据结构用属性列表 + 不变式文字

**ValueStack**（双视图值栈）

底层为一块 `Uint8List` 缓冲区，上面叠加两个视图：

| 属性 | 类型 | 说明 |
|------|------|------|
| intView | Int64List | 整数视图，每槽 8 字节 |
| doubleView | Float64List | 浮点视图，与 intView 共享同一缓冲区 |
| sp | int | 栈顶指针（槽位单位） |

**不变式**：同一槽位在其活跃区间内只通过一种视图访问。编译器的 StackKind 分类保证此约束。

---

### 不合格：流程用完整方法实现

```dart
Object? load(int index, DarticRuntime runtime) {
  final value = slots[index];
  if (identical(value, _initializing)) {
    throw DarticError('Circular dependency...');
  }
  if (identical(value, _uninitialized)) {
    // ... 20 行实现代码
  }
  return value;
}
```

### 合格：流程用编号步骤

**惰性初始化流程**（`LOAD_GLOBAL` 首次访问时触发）：

1. 读取 `slots[index]`
2. 若值为 `_initializing` 哨兵 → 抛出循环依赖错误
3. 若值为 `_uninitialized` 哨兵：
   a. 标记为 `_initializing`（防循环）
   b. 执行初始化函数
   c. 存储结果，返回
   d. 若初始化失败，重置为 `_uninitialized`
4. 否则直接返回已缓存的值

---

### 不合格：IC 用完整实现代码

```dart
Object? _executeCallVirtual(InterpreterFrame frame, int instr) {
  final receiver = _rs.slots[(instr >> 16) & 0xFF];
  // ... 15 行实现
}
```

### 合格：IC 用流程描述

**内联缓存分发流程**：

1. 从 `CALL_VIRTUAL` 指令的 C 操作数取 IC 槽索引
2. **单态命中**：`ic.cachedClassId == receiver.classId` → 直接调用缓存的方法偏移（一次 int 比较，O(1)）
3. **未命中**：查虚方法表（HashMap 查找） → 更新 IC 缓存 → 调用

命中率：典型面向对象代码约 85-95%。命中 vs 未命中性能差约 10-50x。
